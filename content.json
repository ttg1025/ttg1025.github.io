{"meta":{"title":"程序人生","subtitle":"博客日志","description":"","author":"gtt1025","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2020-10-20T01:58:59.000Z","updated":"2020-10-20T01:59:47.003Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-10-20T02:03:19.000Z","updated":"2020-10-20T02:03:49.243Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"关于我","date":"2020-10-20T02:07:02.000Z","updated":"2020-10-20T02:14:43.425Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"时间非常珍贵，莫要白白荒废它！"}],"posts":[{"title":"","slug":"机器学习","date":"2020-11-01T14:01:20.808Z","updated":"2020-11-01T14:01:22.477Z","comments":true,"path":"2020/11/01/机器学习/","link":"","permalink":"http://example.com/2020/11/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"机器学习##定义关于机器学习的定义，从网上查询了一下，主要有以下几种：1、机器学习是一种在没有具体编程的情况下教计算机学习的能力。 2、从大量现象中提取反复出现的规律与模式，机器学习是计算机基于数据构建概率统计模型并运用模型对数据进行预测与分析的学科。 3、机器学习，顾名思义，让机器去学习。这里，机器指的是计算机，是算法运行的物理载体。对于一个任务及其表现的度量方法，设计一种算法，让算法能够提取中数据所蕴含的规律，这就叫机器学习 ##基本步骤收集数据：无论是来自excel, access, text files等文件的原始数据，这一步（收集过去的数据）是未来学习的基础。相关数据的种类、密度和数量越大，机器的学习前景就越好。 准备数据：任何分析过程都依赖于所使用数据的质量。我们需要花时间来确定数据的质量，然后采取措施来解决缺失数据和异常值的处理等问题。探索性分析可能是研究数据细微差别的一种方法，从而迅速提高数据的营养含量。 训练模型：这一步包括选择合适的算法并以模型的形式表示数据。清洗后的数据分为训练和测试两部分（比例视前提而定）。第一部分（训练数据）用于开发模型。第二部分（测试数据），用作参考。 评估模型：为了测试准确性，使用了数据的第二部分(holdout / test data)。这一步根据结果确定算法选择的准确度。检验模型准确性的更好的测试方法是查看其在模型构建过程中根本没有用到的数据上的性能。 提高性能：这一步可能包括选择一个完全不同的模型，或者引入更多的变量来提高效率。这就是为什么需要花费大量的时间来收集和准备数据。 ##机器学习种类监督学习：是利用已知类别的样本（即有标记的样本 labeled sample，已知其相应的类别），调整分类器的参数，训练得到一个最优模型，使其达到所要求性能，再利用这个训练后的模型，将所有的输入映射为相应的输出，对输出进行简单的判断，从而实现分类的目的，这样，即可以对未知数据进行分类。 例如，将邮件进行是否垃圾邮件的分类，一开始我们先将一些邮件及其标签（垃圾邮件或非垃圾邮件）一起进行训练，学习模型不断捕捉这些邮件与标签间的联系进行自我调整和完善，然后我们给一些不带标签的新邮件，让该模型对新邮件进行是否是垃圾邮件的分类。（给出定义好的标签，程序「学习」标签和数据之间的映射关系） 非监督学习：常常被用于数据挖掘，用于在大量无标签数据中发现些什么她的训练数据是无标签的，训练目标是能对观察值进行分类或者区分等。例如非监督学习应该能在不给任何额外提示的情况下，仅依据所有“花”的图片的特征，将“花”的图片从大量的各种各样的图片中将区分出来。（数据集没有标签） 强化学习通常被用在机器人技术上（例如机械狗），它接收机器人当前状态，算法的目标是训练机器来做出各种特定行为。工作流程多是：机器被放置在一个特定环境中，在这个环境里机器可以持续性地进行自我训练，而环境会给出或正或负的反馈。机器会从以往的行动经验中得到提升并最终找到最好的知识内容来帮助它做出最有效的行为决策。（达到目标会有正确反馈） ##主要应用 ** 手写识别（handwriting recognition）**：它可以识别手写文字，这样就可以将手写文字直接转变为数字文字。 语言转换（language translation）：对口语或书面文字进行翻译。 语音识别（speech recognition）：识别语音并将语音片段转换成文本。 图片分类（image classification）：将图片进行合适的分类。 自主驾驶（autonomous driving）：使车能自己行驶。 ##训练数据和测试数据训练数据：训练数据是用来学习模型的。训练数据的质量对生成一个成功的机器学习模型来说至关重要，理想的训练数据应该是多样化并尽可能与模型需要用到的特性相关的。 测试数据：被用来对生成的模型的准确度进行评估的数据。测试数据不能用来训练模型。 ##过拟合和欠拟合过拟合（overfitting）：模型在训练数据上运行的很好但在测试数据上表现糟糕。也就是泛化性能不好，如果太追求在训练集上的完美而采用一个很复杂的模型，会使得模型把训练集里面的噪声都当成了真实的数据分布特征，从而得到错误的数据分布估计。过拟合可以通过正则化或交叉验证技术来避免。 欠拟合（underfitting）：训练样本太少，导致模型就不足以刻画数据分布了，体现为连在训练集上的错误率都很高的现象。 ##机器学习算法监督学习（构建预测模型） 分类(classification)**：这种算法使用训练数据（训练数据中包含特征以及分类标签）来构建预测模型。这些预测模型可以使用它从训练数据中所挖掘出来的特征来对新的、未曾见过的数据集进行分类标签预测，而这种最终的分类结果是相互分离的。常用分类算法：逻辑回归、决策树、KNN、随机森林、支持向量机、朴素贝叶斯等（目标标记为类别型数据(category)**） 回归（regression）：这种算法使用从输入数据中获得的特征参数来预测一些额外的特征，为了完成这一工作，算法会建立一个基于数据特征的模型，这个模型可以针对训练数据给出一些未知的特征，也可以用来预测新数据集的特征属性。这里输出的特征属性是连续的且互不分离的。常见的回归算法：线性回归、KNN、Gradient Boosting &amp; AdaBoost等（**目标标记为连续性数值 (continuous numeric value)**） 无监督学习（构建描述模型） **聚类(clustering)**：这类算法的主要目标是对输入数据进行归类，并将其划分为若干个不同的层级或是类别。算法中这一过程仅仅使用了输入数据中挖掘出来的特征而没有使用任何其他信息。与分类不同的是，聚类中输出数据的各个类别标签我们是无法获知的。常见的聚类算法包括k-means、k-medoids和层次聚类。 **关联（模式挖掘）(association)**：这类算法主要用来从数据集中挖掘和抽取规则和模式。这里的规则阐述了数据中不同参数和属性之间的联系，同时也描画了数据中会经常出现的元素集和模式规律。这些规则和规律可以反过来帮助我们从企业机构的海量数据仓库中发现有意义的内容。常见的这类算法包括Apriori和FP Growth。 ##机器学习与深度学习机器学习擅长替代重复的人工劳动，用机器自动从大量数据中识别模式 Classification 分类，如垃圾邮件识别(detection, ranking) Regression 回归，例如股市预测 Clustering 聚类，如 iPhoto 按人分组 Rule Extraction 规则提取，如数据挖掘 比如垃圾邮件识别的问题，做法是先从每一封邮件中抽取出对识别结果可能有影响的因素（称为特征 feature），比如发件地址、邮件标题、收件人数量等等。然后使用算法去训练数据中每个特征和预测结果的相关度，最终得到可以预测结果的特征。算法再强大，如果无法从数据中「学习到」更好的特征表达，也是徒劳。 但是对机器学习来说，特征提取并不简单。特征工程往往需要人工投入大量时间去研究和调整，就好像原本应该机器解决的问题，却需要人一直在旁边搀扶。 深度学习便是解决特征提取问题的一个机器学习分支。它可以自动学习特征和任务之间的关联，还能从简单特征中提取复杂的特征。 数据量：机器学习能够适应各种数据量，特别是数据量较小的场景。在另一方面，如果数据量迅速增加，那么深度学习的效果将更为突出。下图展示了不同数据量下机器学习与深度学习的效能水平。 硬件依赖性：与传统机器学习算法相反，深度学习算法在设计上高度依赖于高端设备。深度学习算法需要执行大量矩阵乘法运算，因此需要充足的硬件资源作为支持。 特征工程：特征工程是将特定领域知识放入指定特征的过程，旨在减少数据复杂性水平并生成可用于学习算法的模式。示例：传统的机器学习模式专注于特征工程中所需要找像素及其他属性。深度学习算法则专注于数据的其他高级特征，因此能够降低处理每个新问题时特征提取器的实际工作量。 问题解决方法:传统机器学习算法遵循标准程序以解决问题。它将问题拆分成数个部分，对其进行分别解决，而后再将结果结合起来以获得所需的答案。深度学习则以集中方式解决问题，而无需进行问题拆分。 执行时间:执行时间是指训练算法所需要的时间量。深度学习需要大量时间进行训练，因为其中包含更多参数，因此训练的时间投入也更为可观。相对而言，机器学习算法的执行时间则相对较短。 可解释性:可解释性是机器学习与深度学习算法间的主要区别之一——深度学习算法往往不具备可解释性。也正因为如此，业界在使用深度学习之前总会再三考量 未完待续。。。","categories":[],"tags":[]},{"title":"","slug":"识别猫咪","date":"2020-11-01T14:00:34.835Z","updated":"2020-11-01T14:00:39.242Z","comments":true,"path":"2020/11/01/识别猫咪/","link":"","permalink":"http://example.com/2020/11/01/%E8%AF%86%E5%88%AB%E7%8C%AB%E5%92%AA/","excerpt":"","text":"#识别猫咪##导入数据集 12345678910111213141516171819202122232425import numpy as npimport h5pydef load_dataset(): #train_set_x_orig是一个（209,64,64,3）维度的数组（相当于4D）， #train_set_y_orig是一个（209，）的数组，即一维数组 #np.reshape（x，y）：把一个（n,m）的数组变成（x，y）的数组 #np.shape[n]：计算维度n有多少个组数。a.shape=（3,26,51,23），a.shape[0]=3，a.shape[2]=51 train_dataset = h5py.File(&#x27;train_catvnoncat.h5&#x27;,&quot;r&quot;) train_set_x_orig = np.array(train_dataset[&quot;train_set_x&quot;][:]) train_set_y_orig = np.array(train_dataset[&quot;train_set_y&quot;][:]) test_dataset = h5py.File(&#x27;test_catvnoncat.h5&#x27;,&quot;r&quot;) test_set_x_orig = np.array(test_dataset[&quot;test_set_x&quot;][:]) test_set_y_orig = np.array(test_dataset[&quot;test_set_y&quot;][:]) classes = np.array(test_dataset[&quot;list_classes&quot;][:]) train_set_y_orig = train_set_y_orig.reshape((1, train_set_y_orig.shape[0])) test_set_y_orig = test_set_y_orig.reshape((1,test_set_y_orig.shape[0])) #print(&quot;test: %i&quot;,train_set_y_orig.shape[0]) #训练集X矩阵（train_set_x_orig）, 训练集Y矩阵（train_set_y_orig ），测试集X矩阵(test_set_x_orig),测试集Y矩阵（test_set_y_orig）,类别( classes:喵与非喵） return train_set_x_orig, train_set_y_orig, test_set_x_orig, test_set_y_orig, classes ##测试数据是否导入成功 1234567891011121314151617181920212223242526import numpy as npimport h5pyimport matplotlib import matplotlib.pyplot as pltdef load_test(): train_dataset = h5py.File(&#x27;train_catvnoncat.h5&#x27;,&quot;r&quot;) train_set_x_orig = np.array(train_dataset[&quot;train_set_x&quot;][:]) train_set_y_orig = np.array(train_dataset[&quot;train_set_y&quot;][:]) test_dataset = h5py.File(&#x27;test_catvnoncat.h5&#x27;,&quot;r&quot;) test_set_x_orig = np.array(test_dataset[&quot;test_set_x&quot;][:]) test_set_y_orig = np.array(test_dataset[&quot;test_set_y&quot;][:]) classes = np.array(test_dataset[&quot;list_classes&quot;][:]) train_set_y_orig = train_set_y_orig.reshape((1, train_set_y_orig.shape[0])) test_set_y_orig = test_set_y_orig.reshape((1,test_set_y_orig.shape[0])) #print(&quot;test:&quot;,train_set_y_orig.shape[1]) #print(&quot;test:&quot;,train_set_x_orig.shape[0]) #print(&quot;test:&quot;,test_set_y_orig.shape[0]) #print(&quot;test:&quot;,test_set_x_orig.shape[0]) index=25 plt.imshow(train_set_x_orig[index]) # 查看训练集中的图片 plt.show()load_test() ##核心代码（加了注释） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236import numpy as npfrom utils import load_datasetimport scipyimport matplotlib.pyplot as plt#导入数据集train_set_x_orig, train_set_y, test_set_x_orig, test_set_y, classes = load_dataset()#获取基本参数#训练集大小为209m_train = train_set_x_orig.shape[0]#训练集大小为50m_test = test_set_x_orig.shape[0]#图片宽度64num_px = train_set_x_orig.shape[1]#原始图片为三维，将图片降维并转置train_set_x_flatten = train_set_x_orig.reshape(m_train,-1).Ttest_set_x_flatten = test_set_x_orig.reshape(m_test,-1).T#对数据进行归一化：train_set_x = train_set_x_flatten/255test_set_x = test_set_x_flatten/255#激活函数/sigmod函数def sigmod(z): a = 1/(1+np.exp(-z)) return a#参数初始化（w是列向量，传入维度dim，返回shape为（dim# ，1）的w，b就是一个数）def initialize_with_zeros(dim): w = np.zeros((dim,1)) b = 0 #利用断言确定语句正确 assert (w.shape == (dim, 1)) assert (isinstance(b, int) or isinstance(b, float)) return w,b#反向传播和前向传播def propagate(w, b, X, Y): &quot;&quot;&quot; 传参 w -- 权重，shape：(num_px * num_px *3,1) b -- 偏置项，一个标量 X -- 数据集，shape：(num_px * num_px * 3,m),m为样本数 Y -- 真实标签：shape：(1,m) 返回值： cost，dw，db，后两者放在一个字典grads里 &quot;&quot;&quot; #获取样本数m： m = X.shape[1] #前向传播 A = sigmod(np.dot(w.T,X)+b) cost = -(np.sum(Y*np.log(A)+(1-Y)*np.log(1-A)))/m #反向传播 dZ = A-Y dw = (np.dot(X,dZ.T))/m db = (np.sum(dZ))/m # 使用断言确保数据的准确性 assert (dw.shape == w.shape) assert (db.dtype == float) #删除np.shape[x] = 1 的那一个维度 assert(dw.shape == w.shape) assert (db.dtype == float) cost = np.squeeze(cost) assert(cost.shape == ()) #创造一个字典存储返回值： grads = &#123;&quot;dw&quot;: dw, &quot;db&quot;: db&#125; return grads, costdef optimize(w, b, X, Y, num_iterations, learning_rate, print_cost = False): &quot;&quot;&quot; 此函数通过运行梯度下降算法来优化w和b 参数： w - 权重，大小不等的数组（num_px * num_px * 3，1） b - 偏差，一个标量 X - 维度为（num_px * num_px * 3，训练数据的数量）的数组。 Y - 真正的“标签”矢量（如果非猫则为0，如果是猫则为1），矩阵维度为(1,训练数据的数量) num_iterations - 优化循环的迭代次数 learning_rate - 梯度下降更新规则的学习率 print_cost - 每100步打印一次损失值 返回： params - 包含权重w和偏差b的字典 grads - 包含权重和偏差相对于成本函数的梯度的字典 成本 - 优化期间计算的所有成本列表，将用于绘制学习曲线。 &quot;&quot;&quot; #定义一个costs数组，存放每若干次迭代后的cost，从而可以画图看看cost的变化趋势 costs = [] #进行迭代 for i in range(num_iterations): #用propagate计算出每次迭代后的cost和梯度： grads,cost = propagate(w,b,X,Y) dw = grads[&#x27;dw&#x27;] db = grads[&#x27;db&#x27;] #用上面得到的梯度来更新参数 w = w - learning_rate*dw b = b - learning_rate*db #每100次迭代，保存一个cost看看： if i % 100 == 0: costs.append(cost) #每100次将cost打印出来 if print_cost and i % 100 == 0: print(&quot;Cost after iterations %i: %f&quot; %(i,cost)) #迭代结束，将最终的各个参数放入字典，并返回： params = &#123;&quot;w&quot;: w, &quot;b&quot;: b&#125; grads = &#123;&quot;dw&quot;: dw, &quot;db&quot;: db&#125; return params, grads, costs#预测函数def predict(w,b,X): &quot;&quot;&quot; 使用学习逻辑回归参数logistic （w，b）预测标签是0还是1， 参数： w - 权重，大小不等的数组（num_px * num_px * 3，1） b - 偏差，一个标量 X - 维度为（num_px * num_px * 3，训练数据的数量）的数据 返回： Y_prediction - 包含X中所有图片的所有预测【0 | 1】的一个numpy数组（向量） &quot;&quot;&quot; m = X.shape[1] # 用于存储预测值 Y_prediction = np.zeros((1,m)) w = w.reshape(X.shape[0], 1) # 预测猫在图片中实际出现的概率 A = sigmod(np.dot(w.T,X)+b) # 将概率转化为实际值 for i in range(m): if A[:,i]&gt;0.5: Y_prediction[:,i] = 1 else: Y_prediction[:,i] = 0 assert (Y_prediction.shape == (1, m)) return Y_prediction def logistic_model(X_train,Y_train,X_test,Y_test,learning_rate=0.1,num_iterations=2000,print_cost=False): &quot;&quot;&quot; 通过调用之前实现的函数来构建逻辑回归模型 参数： X_train - numpy的数组,维度为（num_px * num_px * 3，m_train）的训练集 Y_train - numpy的数组,维度为（1，m_train）（矢量）的训练标签集 X_test - numpy的数组,维度为（num_px * num_px * 3，m_test）的测试集 Y_test - numpy的数组,维度为（1，m_test）的（向量）的测试标签集 num_iterations - 表示用于优化参数的迭代次数的超参数 learning_rate - 表示optimize（）更新规则中使用的学习速率的超参数 print_cost - 设置为true以每100次迭代打印成本 返回： d - 包含有关模型信息的字典。 &quot;&quot;&quot; #获特征维度，初始化参数： dim = X_train.shape[0] w,b = initialize_with_zeros(dim) #梯度下降，迭代求出模型参数： params,grads,costs = optimize(w,b,X_train,Y_train,num_iterations,learning_rate,print_cost) w = params[&#x27;w&#x27;] b = params[&#x27;b&#x27;] #用学得的参数进行预测： prediction_train = predict(w,b,X_test) prediction_test = predict(w,b,X_train) #计算准确率，分别在训练集和测试集上： #accuracy_train = 1 - np.mean(np.abs(prediction_train - Y_train)) #accuracy_test = 1 - np.mean(np.abs(prediction_test - Y_test)) #print(&quot;Accuracy on train set:&quot;,accuracy_train ) #print(&quot;Accuracy on test set:&quot;,accuracy_test ) print(&quot;train accuracy: &#123;&#125; %&quot;.format(100 - np.mean(np.abs(prediction_train - Y_train)) * 100)) print(&quot;test accuracy: &#123;&#125; %&quot;.format(100 - np.mean(np.abs(prediction_test - Y_test)) * 100)) # print(&quot;测试集的准确性：&quot;, format(100 - np.mean(np.abs(prediction_test - Y_test))), &quot;%&quot;) # print(&quot;训练集的准确性：&quot;, format(100 - np.mean(np.abs(prediction_train - Y_train))), &quot;%&quot;) #为了便于分析和检查，我们把得到的所有参数、超参数都存进一个字典返回出来： d = &#123;&quot;costs&quot;: costs, &quot;Y_prediction_test&quot;: prediction_test , &quot;Y_prediction_train&quot; : prediction_train , &quot;w&quot; : w, &quot;b&quot; : b, &quot;learning_rate&quot; : learning_rate, &quot;num_iterations&quot;: num_iterations #&quot;train_acy&quot;:accuracy_train, #&quot;test_acy&quot;:accuracy_test &#125; return d#测试一下训练结果d = logistic_model(train_set_x, train_set_y, test_set_x, test_set_y, num_iterations = 2000, learning_rate = 0.005, print_cost = True)# 可视化costs=d[&#x27;costs&#x27;]plt.plot(costs)plt.title(&quot;Learning rate = 0.005&quot;)plt.xlabel(&quot;iterations (per hundreds)&quot;)plt.ylabel(&quot;Cost&quot;)plt.show() learning_rates = [0.01, 0.001, 0.0001]models = &#123;&#125;for i in learning_rates: print (&quot;learning rate is: &quot; + str(i)) models[str(i)] = logistic_model(train_set_x, train_set_y, test_set_x, test_set_y, num_iterations = 1500, learning_rate = i, print_cost = False) print (&#x27;\\n&#x27; + &quot;-------------------------------------------------------&quot; + &#x27;\\n&#x27;) for i in learning_rates: plt.plot(np.squeeze(models[str(i)][&quot;costs&quot;]), label= str(models[str(i)][&quot;learning_rate&quot;])) plt.ylabel(&#x27;cost&#x27;)plt.xlabel(&#x27;iterations&#x27;) legend = plt.legend(loc=&#x27;upper center&#x27;, shadow=True)frame = legend.get_frame()frame.set_facecolor(&#x27;0.90&#x27;)plt.show()","categories":[],"tags":[]},{"title":"Ubantu常用命令","slug":"Ubantu常用命令","date":"2020-09-26T04:12:57.000Z","updated":"2020-10-23T09:35:47.644Z","comments":true,"path":"2020/09/26/Ubantu常用命令/","link":"","permalink":"http://example.com/2020/09/26/Ubantu%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"查看端口是否被占用1netstat -tunlp|grep 8888 关掉进程1kill -9 进程号 修改文件夹权限1sudo chmod -R 777 &#x2F;xxx 未完待续…","categories":[{"name":"Ubantu","slug":"Ubantu","permalink":"http://example.com/categories/Ubantu/"}],"tags":[{"name":"Ubantu","slug":"Ubantu","permalink":"http://example.com/tags/Ubantu/"}]},{"title":"Ubantu+Django+Uwsgi+Nginx部署博客","slug":"Ubantu+Django+Uwsgi+Nginx部署博客","date":"2020-09-26T04:12:57.000Z","updated":"2020-10-23T09:35:27.368Z","comments":true,"path":"2020/09/26/Ubantu+Django+Uwsgi+Nginx部署博客/","link":"","permalink":"http://example.com/2020/09/26/Ubantu+Django+Uwsgi+Nginx%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"环境腾讯云 Ubuntu 16.04.1 LTS Django2.0.8 Python3.6.12 Nginx1.10.3 Git 安装Python3.6.12博客部署需要3.6版本的Python 12345sudo suapt-get install software-properties-commonadd-apt-repository ppa:jonathonf&#x2F;python-3.6apt-get updateapt-get install python3.6 使终端默认打开我们安装的python3.6 123cd &#x2F;usr&#x2F;binrm python3ln -s python3.6 python3 安装pip3安装pip用来安装Python的各种包 12345apt-get install python3-pipcd &#x2F;usr&#x2F;binrm pip3ln -s pip3.6 pip3pip3 install --upgrade pip 安装虚拟环境virtualenv1pip3 install virtualenv 选择一个存放虚拟环境的目录 1cd &#x2F;home 创建并激活虚拟环境 12virtualenv djangosource &#x2F;home&#x2F;django&#x2F;bin&#x2F;activate 下载博客源码安装git 12345apt-get install gitcd &#x2F;home&#x2F;mysitegit initgit remote add origin github地址git pull origin master 安装网站所需的Python包首先,进入到Django虚拟环境中，使用如下命令激活环境: 1source &#x2F;home&#x2F;django&#x2F;bin&#x2F;activate 然后，安装Python包 1pip install -r requirements.txt 安装Mysql12345cd &#x2F;homewget https:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;mysql-apt-config_0.8.12-1_all.debdpkg -i mysql-apt-config_0.8.12-1_all.deb # 选择8.0即可apt-get updateapt-get install mysql-server 创建博客的数据库，要与base.py或者settings.py中的数据库一样 1CREATE DATABASE &#96;数据库名&#96; DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci; 在网站根目录创建数据库 12python manage.py makemigrationspython manage.py migrate 如果出现报错，可指定具体应用，这个应用一定要添加到settings.py中的INSTALLED_APPS里 12python manage.py makemigrations blogpython manage.py migrate 运行博客切换到根目录运行 1python manage.py runserver 0.0.0.0:80 0.0.0.0:80表示任意ip可访问 安装配置uwsgi安装uwsgi和所需工具包 123apt-get install python3.6-devpip3 install uwsgiuwsgi --http :8888 --chdir &#x2F;home&#x2F;mysite&#x2F;DjangoBlog --home &#x2F;home&#x2F;django --module djangoblog.wsgi:application –http ：用于指定端口，这里指定8888 –chdir：用于指定网站根目录 –home：用于指定虚拟环境地址 –module：settings.py中的WSGI_APPLICATION，用于指定项目地址 执行命令太麻烦，配置一下在/home下新建mysite_uwsgi目录，然后新建Mysite.ini配置文件用来保存uwsgi的配置文件 1234cd &#x2F;homemkdir mysite_uwsgicd mysite_uwsgivim mysite.ini 写入下面的内容 123456789101112131415[uwsgi]chdir &#x3D; &#x2F;home&#x2F;mysite&#x2F;djangobloghome &#x3D; &#x2F;home&#x2F;djangomodule &#x3D; djangoblog.wsgi:applicationmaster &#x3D; Trueprocesses &#x3D; 4max-requests &#x3D; 5000harakiri &#x3D; 60socket &#x3D; :8888uid &#x3D; rootgid &#x3D; rootpidfile &#x3D; &#x2F;home&#x2F;mysite_uwsgi&#x2F;master.piddaemonize &#x3D; &#x2F;home&#x2F;mysite_uwsgi&#x2F;mysite.logvacuum &#x3D; Truebufffer_size &#x3D; 66536 #缓存不能太小 打开uwsgi 1uwsgi --ini &#x2F;home&#x2F;mysite_uwsgi&#x2F;mysite.ini 检查uwsgi是否启动成功的命令 1ps -aux | grep uwsgi 安装配置nginx安装nginx 1apt-get install nginx 修改配置文件 12cd &#x2F;etc&#x2F;nginx&#x2F;sites-availablevim mysite.conf 写入下面内容 1234567891011121314151617181920212223242526upstream django &#123; server ip:8888; # for a web port socket (we&#39;ll use this first)&#125;server&#123; listen 80; server_name mysite; charset utf-8; client_max_body_size 75M; #上传文件大小限制 # 网站静态文件所在目录 location &#x2F;static&#123; alias &#x2F;home&#x2F;mysite&#x2F;DjangoBlog&#x2F;static; &#125; # 上传文件所在目录 location &#x2F;media&#123; alias &#x2F;home&#x2F;mysite&#x2F;DjangoBlog&#x2F;media; &#125; # 动态文件交给uwsgi处理 location &#x2F; &#123; uwsgi_pass ip:8888; include &#x2F;etc&#x2F;nginx&#x2F;uwsgi_params; &#125;&#125; 网站静态文件所在目录一定要配置正确 uwsgi和nginx通信时，要么都用socket，要么都用http；用http时，uwsgi的配置文件中要用内网ip，nignx用公网 如果/home/mysite/DjangoBlog目录下没有static目录，配置settings.py 1234567# 静态文件路径STATIC_URL = &#x27;/static/&#x27;#STATIC_ROOT = os.path.join(BASE_DIR,&#x27;static/&#x27;)STATIC_ROOT = &#x27;F:\\Python\\blog\\DjangoBlog\\apps\\blog\\staic&#x27;STATICFILES_DIRS=[os.path.join(BASE_DIR,&#x27;static/&#x27;)，] 然后执行,收集static文件 1python manage.py collectstatic 执行完毕后，再改回来 1234567# 静态文件路径STATIC_URL = &#x27;/static/&#x27;STATIC_ROOT = os.path.join(BASE_DIR,&#x27;static/&#x27;)#STATIC_ROOT = &#x27;F:\\Python\\blog\\DjangoBlog\\apps\\blog\\staic&#x27;STATICFILES_DIRS=[os.path.join(BASE_DIR,&#x27;static/&#x27;)，] 在sites-enabled中创建一个软连接，表示此配置文件已经启用 1ln -s &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;mysite.conf &#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F;mysite.conf 修改/etc/nginx/nginx.conf，将user后面改为root重启nginx 1service nginx restart 浏览器输入ip访问49.235.229.91","categories":[{"name":"工具部署","slug":"工具部署","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://example.com/tags/Django/"}]},{"title":"VSCode配置C/C++的编译环境","slug":"VSCode配置C-C++的编译环境","date":"2020-09-26T04:12:57.000Z","updated":"2020-10-23T09:32:01.427Z","comments":true,"path":"2020/09/26/VSCode配置C-C++的编译环境/","link":"","permalink":"http://example.com/2020/09/26/VSCode%E9%85%8D%E7%BD%AEC-C++%E7%9A%84%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/","excerpt":"","text":"安装vsCodeVSCode 安装C/C++扩展安装编译环境mingw-w64mingw-w64安装完毕之后，配置环境变量，此电脑-属性-高级系统设置-环境变量-系统变量-path-添加一条D:\\mingw\\mingw32\\bin\\（你安装的编译环境的地址） 配置VScodelaunch.json 123456789101112131415161718192021222324252627&#123; &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;(gdb) Launch&quot;, &#x2F;&#x2F; 配置名称，将会在启动配置的下拉菜单中显示 &quot;type&quot;: &quot;cppdbg&quot;, &#x2F;&#x2F; 配置类型，这里只能为cppdbg &quot;request&quot;: &quot;launch&quot;, &#x2F;&#x2F; 请求配置类型，可以为launch（启动）或attach（附加） &quot;program&quot;: &quot;$&#123;workspaceRoot&#125;&#x2F;$&#123;fileBasenameNoExtension&#125;.exe&quot;,&#x2F;&#x2F; 将要进行调试的程序的路径 &quot;args&quot;: [], &#x2F;&#x2F; 程序调试时传递给程序的命令行参数，一般设为空即可 &quot;stopAtEntry&quot;: false, &#x2F;&#x2F; 设为true时程序将暂停在程序入口处，一般设置为false &quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;&quot;,&#x2F;&#x2F; 调试程序时的工作目录，一般为$&#123;workspaceRoot&#125;即代码所在目录 &quot;environment&quot;: [], &quot;externalConsole&quot;: true,&#x2F;&#x2F; 调试时是否显示控制台窗口，一般设置为true显示控制台 &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;D:\\\\MinGW\\\\bin\\\\gdb.exe&quot;,&#x2F;&#x2F; miDebugger的路径，注意这里要与MinGw的路径对应 &quot;preLaunchTask&quot;: &quot;g++&quot;, &#x2F;&#x2F; 调试会话开始前执行的任务，一般为编译程序，c++为g++, c为gcc &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125; ] &#125; ]&#125; task.json 1234567891011121314151617181920212223242526272829&#123; &quot;version&quot;: &quot;2.0.0&quot;, &quot;command&quot;: &quot;g++&quot;, &quot;args&quot;: [ &quot;-g&quot;, &quot;$&#123;file&#125;&quot;, &quot;-o&quot;, &quot;$&#123;fileDirname&#125;&#x2F;$&#123;fileBasenameNoExtension&#125;.exe&quot; ], &quot;problemMatcher&quot;: &#123; &quot;owner&quot;: &quot;cpp&quot;, &quot;fileLocation&quot;: [ &quot;relative&quot;, &quot;$&#123;workspaceRoot&#125;&quot; ], &quot;pattern&quot;: &#123; &quot;regexp&quot;: &quot;^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$&quot;, &quot;file&quot;: 1, &quot;line&quot;: 2, &quot;column&quot;: 3, &quot;severity&quot;: 4, &quot;message&quot;: 5 &#125; &#125;, &quot;group&quot;: &#123; &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true &#125; &#125;","categories":[{"name":"工具部署","slug":"工具部署","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"VSCode","slug":"VSCode","permalink":"http://example.com/tags/VSCode/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-09-26T04:12:57.000Z","updated":"2020-10-20T02:04:22.057Z","comments":true,"path":"2020/09/26/hello-world/","link":"","permalink":"http://example.com/2020/09/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"测试","slug":"测试","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"HelloWorld","slug":"HelloWorld","permalink":"http://example.com/tags/HelloWorld/"}]},{"title":"Ubantu环境下Git和Github的安装使用","slug":"Ubantu环境下Git和Github的安装使用","date":"2020-09-26T04:12:57.000Z","updated":"2020-10-23T09:36:12.375Z","comments":true,"path":"2020/09/26/Ubantu环境下Git和Github的安装使用/","link":"","permalink":"http://example.com/2020/09/26/Ubantu%E7%8E%AF%E5%A2%83%E4%B8%8BGit%E5%92%8CGithub%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Git安装1sudo apt-get isntall git 配置Git12git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;email@example.com&quot; 下载文件1git clone githu上仓库地址 生成并添加密钥生成密钥 1ssh-keygen -t rsa -C &quot;email@example.com&quot; 查看公钥 1cat ~&#x2F;.ssh&#x2F;id_rsa.pub 在github上添加ssh key，测试连接是否成功 1ssh -T git@github.com 使用git在本地文件夹初始化 1git init 添加文件 1git add . 连接远程仓库 1git remote add origin github上仓库地址 托付文件 1git commit -m &quot;first commit&quot; 提交文件 1git push origin master 在提交文件之前可以先拉去文件 1git pull origin master 新建并切换分支新建分支 1git branch [branch name] 切换分支 1git checkout [branch name] 将新分支push到GitHub上 1git push origin [branch name] 切换到主分支 1git checkout master 将分支合并到主分支 1git merge [branch name]","categories":[{"name":"工具部署","slug":"工具部署","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"Ubantu","slug":"Ubantu","permalink":"http://example.com/tags/Ubantu/"},{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"}]},{"title":"hexo+Github搭建个人博客","slug":"hexo+Github搭建个人博客","date":"2020-09-26T04:12:57.000Z","updated":"2020-10-23T09:31:08.644Z","comments":true,"path":"2020/09/26/hexo+Github搭建个人博客/","link":"","permalink":"http://example.com/2020/09/26/hexo+Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"所需环境Windows10npm 6.14.6node.js v12.18.4githexo 安装Node.jsNode.js查看版本 12node -vnpm -v hexo安装hexo1npm install -g hexo-cli 初始化cd到一个指定目录 1hexo init blog blog是将要建立文件夹的名字cd到blog下面，安装npm 1npm install 开启本地服务器 1hexo s 此时，浏览器中打开网址(默认是4000端口) http://localhost:4000至此播客一搭建成功，接下来配置github 配置github创建名为xxx.github.io的仓库，README初始化也要勾上，名称要与github名称一样，你如github名称为ttg1025，那么仓库就要名为ttg1025.github.io 点击settings，向下拉到最后有一个 Github Pages ，点击 choose a theme 选择一个主题. 打开仓库添加一个index.html,随便写点内容打开地址http://ttg1025.github.io就可以看到了 配置ssh keygit教程就不再赘述 部署到github连接本地和github 修改根目录下的 _config.yml 1234deploy: type: git repository: git@github.com:ttg1025&#x2F;ttg1025.github.io.git branch: master 安装部署插件 hexo-deployer-git1npm install hexo-deployer-git --save 执行以下命令发布 1hexo d -g 打开地址http://ttg1025.github.io就可以看到了 绑定域名阿里云解析域名在阿里云购买域名后，解析域名 github绑定域名点击github仓库中的settings，拉到github上的Github Pages，填上购买的域名点击保存后，Github Pages会自动生成一个CNAME，CNAME中填写的就是域名 常用指令12345hexo new &quot;postName&quot; &#x2F;&#x2F;新建文章hexo new page &quot;pageName&quot; &#x2F;&#x2F;新建页面hexo g &#x2F;&#x2F;生成静态页面至public目录hexo server &#x2F;&#x2F;开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）hexo deploy &#x2F;&#x2F;将.deploy目录部署到GitHub 常用组合123hexo cleanhexo ghexo d","categories":[{"name":"工具部署","slug":"工具部署","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"hexo博客添加分类、标签","slug":"hexo博客添加分类、标签","date":"2020-09-26T04:12:57.000Z","updated":"2020-10-23T09:39:18.725Z","comments":true,"path":"2020/09/26/hexo博客添加分类、标签/","link":"","permalink":"http://example.com/2020/09/26/hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E3%80%81%E6%A0%87%E7%AD%BE/","excerpt":"","text":"创建”分类”标签进入博客根目录，执行命令 1$ hexo new page categories 成功后，会生成index.md,打开后添加type: “categories” 12345---title: categoriesdate: 2020-10-20 09:58:59type: &quot;categories&quot;--- 给文章添加分类属性 1234567---title: Hello Worlddate: 2020-09-26 12:12:57categories: - 测试--- 创建”标签”目录进入博客根目录，执行命令 1$ hexo new page tags 成功后，会生成index.md,打开后添加type: “tags” 12345---title: tagsdate: 2020-10-20 09:58:59type: &quot;tags&quot;--- 给文章添加标签属性 123456789---title: Hello Worlddate: 2020-09-26 12:12:57categories: - 测试tags:- HelloWorld--- 添加”关于”页面执行命令 1hexo new page &quot;about&quot; 更改主题配置文件 123456789101112menu: home: &#x2F; || fa fa-home about: &#x2F;about&#x2F; || fa fa-user tags: &#x2F;tags&#x2F; || fa fa-tags categories: &#x2F;categories&#x2F; || fa fa-th archives: &#x2F;archives&#x2F; || fa fa-archive #schedule: &#x2F;schedule&#x2F; || fa fa-calendar #sitemap: &#x2F;sitemap.xml || fa fa-sitemap #commonweal: &#x2F;404&#x2F; || fa fa-heartbeat # schedule: &#x2F;schedule&#x2F; || calendar # 日历 # sitemap: &#x2F;sitemap.xml || sitemap # 站点地图 # commonweal: &#x2F;404&#x2F; || heartbeat # 腾讯公益404 然后修改source/about/目录中的index.md文件即可","categories":[{"name":"工具部署","slug":"工具部署","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"将hexo博客的主题更改为next","slug":"将hexo博客的主题更改为next","date":"2020-09-26T04:12:57.000Z","updated":"2020-10-23T09:36:40.294Z","comments":true,"path":"2020/09/26/将hexo博客的主题更改为next/","link":"","permalink":"http://example.com/2020/09/26/%E5%B0%86hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%94%B9%E4%B8%BAnext/","excerpt":"","text":"更改基本信息更改网站标题、副标题、作者、英文等 12345678# Sitetitle: 程序人生subtitle: &#39;博客日志&#39;description: &#39;&#39;keywords:author: gtt1025language: zh-CNtimezone: &#39;&#39; 安装next在博客根目录下Git Bash 1git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next 打开根目录下的配置文件，将theme修改为next 1theme: next 点击next目录下的配置文件，选择样式主题,这里一般选择Gemini 12345678# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini 更改菜单栏点击next目录下的配置文件进行修改 123456789101112menu: home: &#x2F; || fa fa-home about: &#x2F;about&#x2F; || fa fa-user tags: &#x2F;tags&#x2F; || fa fa-tags categories: &#x2F;categories&#x2F; || fa fa-th archives: &#x2F;archives&#x2F; || fa fa-archive #schedule: &#x2F;schedule&#x2F; || fa fa-calendar #sitemap: &#x2F;sitemap.xml || fa fa-sitemap #commonweal: &#x2F;404&#x2F; || fa fa-heartbeat # schedule: &#x2F;schedule&#x2F; || calendar # 日历 # sitemap: &#x2F;sitemap.xml || sitemap # 站点地图 # commonweal: &#x2F;404&#x2F; || heartbeat # 腾讯公益404 修改社交信息1234567891011social: GitHub: https:&#x2F;&#x2F;xxxx || fab fa-github E-Mail:xxx@xxx.xx|| fa fa-envelope #Weibo: https:&#x2F;&#x2F;weibo.com&#x2F;yourname || fab fa-weibo #Google: https:&#x2F;&#x2F;plus.google.com&#x2F;yourname || fab fa-google #Twitter: https:&#x2F;&#x2F;twitter.com&#x2F;yourname || fab fa-twitter #FB Page: https:&#x2F;&#x2F;www.facebook.com&#x2F;yourname || fab fa-facebook #StackOverflow: https:&#x2F;&#x2F;stackoverflow.com&#x2F;yourname || fab fa-stack-overflow #YouTube: https:&#x2F;&#x2F;youtube.com&#x2F;yourname || fab fa-youtube #Instagram: https:&#x2F;&#x2F;instagram.com&#x2F;yourname || fab fa-instagram #Skype: skype:yourname?call|chat || fab fa-skype 圆形头像设置1234567avatar: # Replace the default image and set the url here. url: &#x2F;images&#x2F;gtt.jpg #头像文件目录 # If true, the avatar will be dispalyed in circle. rounded: true # If true, the avatar will be rotated with the cursor. rotated: true","categories":[{"name":"工具部署","slug":"工具部署","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]}],"categories":[{"name":"Ubantu","slug":"Ubantu","permalink":"http://example.com/categories/Ubantu/"},{"name":"工具部署","slug":"工具部署","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7%E9%83%A8%E7%BD%B2/"},{"name":"测试","slug":"测试","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"Ubantu","slug":"Ubantu","permalink":"http://example.com/tags/Ubantu/"},{"name":"Django","slug":"Django","permalink":"http://example.com/tags/Django/"},{"name":"VSCode","slug":"VSCode","permalink":"http://example.com/tags/VSCode/"},{"name":"HelloWorld","slug":"HelloWorld","permalink":"http://example.com/tags/HelloWorld/"},{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]}